const $ = async (...cmd: string[]) => {
  const proc = new Deno.Command(cmd.join(" "), {
    stdout: "piped",
    stderr: "piped",
  });
  const childProc = proc.spawn();
  const status = await childProc.status;
  return status.code;
};

const API_DOCS_PATH = new URL("./api_docs", import.meta.url);
if (!(await Deno.lstat(API_DOCS_PATH).catch(() => false))) {
  console.log("API Docs not found locally, cloning repository.");
  await $(
    "git",
    "clone",
    "https://github.com/discord/discord-api-docs",
    API_DOCS_PATH.pathname,
  );
} else {
  console.log("Pulling Latest API Docs");
  Deno.chdir(API_DOCS_PATH);
  await $("git", "pull");
}

interface Endpoint {
  title: string;
  name: string;
  method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
  url: string;
  params: string[];
}

const endpoints: Endpoint[] = [];

async function handleEntry(
  dir: URL,
  { isFile, isDirectory, name }: Deno.DirEntry,
) {
  if (name === ".git") return;

  if (isFile) {
    if (name.endsWith(".md")) {
      const data = await Deno.readTextFile(new URL(dir.href + "/" + name));

      for (
        let [_, name, method, url] of data.matchAll(
          /#+ ([a-zA-Z0-9_ \-]+) % (GET|POST|PUT|DELETE|PATCH) ([a-zA-Z0-9\.\- /{}#_@]+)/g,
        )
      ) {
        name = name.replaceAll("Modify", "Edit");
        const params = [
          ...url.matchAll(/{([a-zA-Z0-9_/\-\.]+)#DOCS_([a-zA-Z0-9_\-/]+)}/g),
        ].map((
          e,
        ) => [
          e[0],
          e[1].split(/(\.| +)/).map((e) =>
            e === "id" ? "ID" : `${e[0].toUpperCase()}${e.slice(1)}`
          ).join("").replaceAll(".", "").replaceAll(" ", ""),
        ]);

        for (const param of params) {
          url = url.replace(param[0], "${" + param[1] + "}");
        }

        let title = name;
        name = name.split(" ").join("").replaceAll("-", "").trim();

        if (
          name === "ListActiveThreads" && params.find((e) => e[1] === "GuildID")
        ) {
          name = "ListActiveGuildThreads";
          title = "List Active Guild Threads";
        }

        if (endpoints.find((e) => e.name === name)) {
          throw new Error(`Found endpoint with same name: ${name}`);
        }

        endpoints.push({
          title,
          name,
          method: method as Endpoint["method"],
          url,
          params: params.map((e) => e[1]),
        });
      }
    }
  } else if (isDirectory) {
    const path = new URL(dir.href + "/" + name);
    for await (const entry of Deno.readDir(path)) {
      await handleEntry(path, entry);
    }
  } else throw new Error("Invalid entry");
}

for await (const entry of Deno.readDir(API_DOCS_PATH)) {
  if (entry.name !== "docs" || !entry.isDirectory) continue;
  await handleEntry(API_DOCS_PATH, entry);
}

let types =
  `// NOTE: This file is auto-generated by scripts/endpoint_typegen.ts\n\nimport { snowflake } from "./common.ts";\n\n`;

function getParamType(name: string): string {
  if (name.endsWith("ID")) {
    return "snowflake";
  } else if (
    name.endsWith("Token") || name.endsWith("Emoji") || name.endsWith("Code")
  ) {
    return "string";
  } else throw new Error(`Unable to infer Param Type: ${name}`);
}

for (const endpoint of endpoints) {
  types += `/**\n * ${endpoint.title}\n * @method ${endpoint.method}\n */\n`;
  types += `export type ${endpoint.name}Endpoint`;
  if (endpoint.params.length) {
    types += `<\n`;
    for (const param of endpoint.params) {
      const type = getParamType(param);
      types += `  ${param} extends ${type} = ${type},\n`;
    }
    types += `>`;
  }
  types += ` = \`${endpoint.url}\`;\n\n`;
}

types += `export type Endpoint =\n`;
for (const _ in endpoints) {
  const i = Number(_);
  const endpoint = endpoints[i];
  types += `  | ${endpoint.name}Endpoint${
    i === endpoints.length - 1 ? ";" : ""
  }\n`;
}

const TYPES_FILE = new URL("../types/src/endpoints.ts", import.meta.url);
await Deno.writeTextFile(
  TYPES_FILE,
  types,
);

await $(
  "deno",
  "fmt",
  "-c",
  new URL("../Deno.jsonc", import.meta.url).pathname,
  TYPES_FILE.pathname,
);

console.log("Generated Endpoint Types!");
